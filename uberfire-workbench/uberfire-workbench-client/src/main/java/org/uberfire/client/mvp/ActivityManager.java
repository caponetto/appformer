/*
 * Copyright 2015 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.uberfire.client.mvp;

import java.util.Set;

import org.jboss.errai.ioc.client.api.ActivatedBy;
import org.jboss.errai.ioc.client.container.SyncBeanManager;
import org.uberfire.client.annotations.WorkbenchEditor;
import org.uberfire.client.annotations.WorkbenchScreen;
import org.uberfire.mvp.PlaceRequest;

/**
 * A facility for obtaining references to specific {@link Activity} instances and for enumerating or discovering all
 * available activities of a certain type (screens, editors, popup dialogs, and so on). Also responsible for shutting
 * down and releasing Activity instances when they are no longer needed.
 * <p>
 * Note that you may never need to use an ActivityManager. While used extensively within the framework, UberFire
 * application code rarely comes into direct contact with activities, which are essentially autogenerated wrappers
 * around classes annotated with {@link WorkbenchScreen}, {@link WorkbenchEditor}, and friends.
 * Most Activity-related tasks can be accomplished at arm's length through a {@link PlaceManager}.
 * <p>
 * If you do need an instance of ActivityManager in your application, obtain it using {@code @Inject}.
 * @see PlaceManager
 * @see Activity
 */
public interface ActivityManager {

    /**
     * Obtains the set of activity instances which implement the given type, are {@link ActivatedBy active}, and that
     * the current user.
     * @param abstractScreenActivityClass the type of activities to enumerate. Must not be null. Passing in {@code Activity.class} will yield
     * all possible activity types.
     * @return the set of available activities. Never null. Each object in the returned set must be freed by the caller
     * via a call to {@link SyncBeanManager#destroyBean(Object)}.
     * @deprecated this method returns Activity instances that have not had their onStartup() methods invoked, so they
     * can not be displayed according to the normal Activity lifecycle. It is also up to the caller to free
     * each of the returned Activity instances by calling {@link SyncBeanManager#destroyBean(Object)} on
     * them. Consider using the Errai bean manager and UberFire AuthorizationManager directly instead of
     * using this method. See UF-105 for details.
     */
    @Deprecated
    <T extends Activity> Set<T> getActivities(final Class<T> abstractScreenActivityClass);

    /**
     * Calls to {@link #getActivities(PlaceRequest)} with security checks enabled.
     */
    Set<Activity> getActivities(final PlaceRequest placeRequest);

    /**
     * Returns an active, accessible activity that can handle the given PlaceRequest. In case there are multiple
     * activities that can handle the given place request, one of them is chosen at random. TODO (UF-92) : make this
     * deterministic.
     * @param placeRequest
     * @return an activity that handles the given PlaceRequest, or null if no available activity can handle. <b>No
     * actual type checking is performed! If you guess the type wrong, you will have an instance of the
     * wrong type. The only truly "safe" type to guess is {@link Activity}.</b>.
     */
    boolean containsActivity(final PlaceRequest placeRequest);

    /**
     * Calls to as {@link #getActivity(PlaceRequest)} with security checks enabled.
     */
    Activity getActivity(final PlaceRequest placeRequest);

    /**
     * Calls to as {@link #getActivity(Class, PlaceRequest)} with security checks enabled.
     */
    <T extends Activity> T getActivity(final Class<T> clazz,
                                       final PlaceRequest placeRequest);

    /**
     * Destroys the given Activity bean instance, making it eligible for garbage collection.
     * @param activity the activity instance to destroy. <b>Warning: do not use with instances of SplashScreenActivity. These
     * are ApplicationScoped and cannot be destroyed.</b>
     * @throws IllegalArgumentException if {@code activity} is a SplashScreenActivity. TODO (UF-91) : fix this.
     */
    void destroyActivity(final Activity activity);

    /**
     * Returns true if the given Activity instance is currently in the <i>started</i> or <i>open</i> state and managed
     * by this ActivityManager.
     * @param activity the activity to check
     * @return true if the activity is started; false if it is uninitialized.
     */
    boolean isStarted(final Activity activity);
}
